<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abercrombie's Synthetic Emotional States - Mathematical Implementation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,700;1,400&family=Cormorant+Garamond:wght@300;400;600&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f5f0 0%, #e8e8e0 100%);
            color: #2c2c2c;
            font-family: 'Crimson Text', serif;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 10px;
        }
        
        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 300;
            font-size: 2.5em;
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 10px;
        }
        
        h2 {
            font-family: 'Cormorant Garamond', serif;
            color: #2c2c5c;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            font-style: italic;
            color: #666;
            margin-bottom: 40px;
        }
        
        .equation-display {
            background: #f9f9f9;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4a4a7e;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #444;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        button {
            background: #4a4a7e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Crimson Text', serif;
            font-size: 1em;
            margin: 5px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5a5a8e;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        
        .vis-container {
            text-align: center;
        }
        
        canvas {
            border: 1px solid #ddd;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4a4a7e;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        
        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        
        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .debug-info {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
            margin: 10px 0;
        }
        
        #error-display {
            color: #d9534f;
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Mathematical Foundations of Synthetic Emotional States</h1>
        <p class="subtitle">Dr. P. L. Abercrombie's Dynamic Matrix Theory (1911) — Interactive Implementation</p>
        
        <div class="equation-display">
            ∂M/∂t = Φ(M) + δM_resonance<br>
            where Φ(M) = AM + MA^T - λM⊙³
        </div>
        
        <h2>Control Parameters</h2>
        
        <div class="controls">
            <div class="control-group">
                <label>Matrix Dimension (n)</label>
                <input type="range" id="dimension" min="3" max="15" value="8" step="1">
                <span id="dimension-display">n = 8</span>
            </div>
            
            <div class="control-group">
                <label>Evolution Rate (ε)</label>
                <input type="range" id="epsilon" min="0.001" max="0.05" step="0.001" value="0.01">
                <span id="epsilon-display">ε = 0.010</span>
            </div>
            
            <div class="control-group">
                <label>Entropy Factor (λ)</label>
                <input type="range" id="lambda" min="0.01" max="0.5" step="0.01" value="0.1">
                <span id="lambda-display">λ = 0.10</span>
            </div>
            
            <div class="control-group">
                <label>Reinforcement (η)</label>
                <input type="range" id="eta" min="0.01" max="0.3" step="0.01" value="0.05">
                <span id="eta-display">η = 0.05</span>
            </div>
            
            <div class="control-group">
                <label>Damping (γ)</label>
                <input type="range" id="gamma" min="0.01" max="0.2" step="0.01" value="0.03">
                <span id="gamma-display">γ = 0.03</span>
            </div>
            
            <div class="control-group">
                <label>Hereditary Strength (α)</label>
                <input type="range" id="alpha" min="0.1" max="1.0" step="0.1" value="0.5">
                <span id="alpha-display">α = 0.5</span>
            </div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <button id="play-pause">Pause</button>
            <button id="reset">Reset Matrix</button>
            <button id="export-data">Export Data</button>
            <button id="test-theorem">Test Inequality</button>
        </div>
        
        <div id="error-display"></div>
        
        <h2>System Visualization</h2>
        
        <div class="visualization-grid">
            <div class="vis-container">
                <h3>Connectivity Matrix M(t)</h3>
                <canvas id="matrix-canvas" width="400" height="400"></canvas>
            </div>
            <div class="vis-container">
                <h3>Eigenvalue Spectrum</h3>
                <canvas id="spectrum-canvas" width="400" height="400"></canvas>
            </div>
        </div>
        
        <h2>Evolution Metrics</h2>
        
        <div class="metrics-display">
            <div class="metric-card">
                <div class="metric-value" id="lambda-max">0.000</div>
                <div class="metric-label">λ_max (Felicity)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="frobenius-norm">0.000</div>
                <div class="metric-label">||M||_F</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="dlambda-dt">0.000</div>
                <div class="metric-label">dλ_max/dt</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="inequality-rhs">0.000</div>
                <div class="metric-label">η λ²_max - λ ||M||²_F</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="time-step">0</div>
                <div class="metric-label">Time Steps</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="stability">Stable</div>
                <div class="metric-label">System State</div>
            </div>
        </div>
        
        <div id="theorem-test-results" class="alert alert-info" style="display: none;">
            <h3>Thermodynamic Inequality Test</h3>
            <div id="test-output"></div>
        </div>
        
        <div class="debug-info">
            <strong>Debug Info:</strong> <span id="debug-status">System initialized</span>
        </div>
    </div>
    
    <script>
        // Debug logging function
        function debugLog(message) {
            console.log(`[Abercrombie Debug] ${message}`);
            document.getElementById('debug-status').textContent = message;
        }
        
        // Error display function
        function showError(message) {
            document.getElementById('error-display').textContent = `Error: ${message}`;
            console.error(`[Abercrombie Error] ${message}`);
        }
        
        // Clear error display
        function clearError() {
            document.getElementById('error-display').textContent = '';
        }
        
        /**
         * Enhanced Abercrombie Matrix Implementation
         * With comprehensive error handling and debugging
         */
        class AbercrombieMatrix {
            constructor(n = 8) {
                try {
                    debugLog(`Initializing matrix system with dimension n=${n}`);
                    
                    // Validate dimension
                    if (n < 3 || n > 20) {
                        throw new Error(`Invalid dimension ${n}. Must be between 3 and 20.`);
                    }
                    
                    this.n = n;
                    this.dt = 0.01;
                    this.time = 0;
                    this.timeSteps = 0;
                    
                    // Parameters
                    this.epsilon = 0.01;
                    this.lambda = 0.1;
                    this.eta = 0.05;
                    this.gamma = 0.03;
                    this.alpha = 0.5;
                    
                    // Initialize matrices
                    this.M = this.initializeMatrix();
                    this.A = this.initializeHereditaryKernel();
                    
                    // Tracking
                    this.history = {
                        time: [],
                        lambdaMax: [],
                        frobeniusNorm: [],
                        dLambdaDt: [],
                        inequalityRHS: []
                    };
                    
                    // Eigenvalue data
                    this.eigenvalues = [];
                    this.lambdaMax = 0;
                    this.vMax = new Array(n).fill(0);
                    this.lastLambdaMax = 0;
                    
                    // Canvas setup with error handling
                    this.setupCanvas();
                    
                    this.isRunning = true;
                    
                    debugLog('Matrix system initialized successfully');
                    clearError();
                    
                } catch (error) {
                    showError(`Initialization failed: ${error.message}`);
                    throw error;
                }
            }
            
            setupCanvas() {
                try {
                    this.matrixCanvas = document.getElementById('matrix-canvas');
                    this.spectrumCanvas = document.getElementById('spectrum-canvas');
                    
                    if (!this.matrixCanvas || !this.spectrumCanvas) {
                        throw new Error('Canvas elements not found');
                    }
                    
                    this.matrixCtx = this.matrixCanvas.getContext('2d');
                    this.spectrumCtx = this.spectrumCanvas.getContext('2d');
                    
                    if (!this.matrixCtx || !this.spectrumCtx) {
                        throw new Error('Failed to get canvas context');
                    }
                    
                } catch (error) {
                    showError(`Canvas setup failed: ${error.message}`);
                    throw error;
                }
            }
            
            initializeMatrix() {
                debugLog(`Creating ${this.n}x${this.n} symmetric matrix`);
                const M = [];
                for (let i = 0; i < this.n; i++) {
                    M[i] = new Array(this.n);
                    for (let j = 0; j < this.n; j++) {
                        if (j >= i) {
                            M[i][j] = (Math.random() - 0.5) * 0.2;
                        } else {
                            M[i][j] = M[j][i]; // Ensure symmetry
                        }
                    }
                }
                return M;
            }
            
            initializeHereditaryKernel() {
                debugLog(`Creating hereditary kernel A with coupling strength α=${this.alpha}`);
                const A = [];
                for (let i = 0; i < this.n; i++) {
                    A[i] = new Array(this.n);
                    for (let j = 0; j < this.n; j++) {
                        const distance = Math.abs(i - j);
                        const coupling = Math.exp(-distance / (this.n * 0.2));
                        A[i][j] = this.alpha * coupling + 0.1 * (Math.random() - 0.5);
                    }
                    A[i][i] = Math.max(A[i][i], 0.5); // Ensure positive diagonal
                }
                return A;
            }
            
            // Safe matrix multiplication with dimension checking
            matmul(A, B) {
                if (!A || !B || !A[0] || !B[0]) {
                    throw new Error('Invalid matrices for multiplication');
                }
                
                const n = A.length;
                const m = A[0].length;
                const p = B[0].length;
                
                if (B.length !== m) {
                    throw new Error(`Matrix dimension mismatch: A is ${n}x${m}, B is ${B.length}x${p}`);
                }
                
                const C = [];
                for (let i = 0; i < n; i++) {
                    C[i] = new Array(p).fill(0);
                    for (let j = 0; j < p; j++) {
                        for (let k = 0; k < m; k++) {
                            C[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                return C;
            }
            
            transpose(M) {
                const n = M.length;
                const MT = [];
                for (let i = 0; i < n; i++) {
                    MT[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        MT[i][j] = M[j][i];
                    }
                }
                return MT;
            }
            
            hadamardCube(M) {
                const n = M.length;
                const M3 = [];
                for (let i = 0; i < n; i++) {
                    M3[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        M3[i][j] = M[i][j] * M[i][j] * M[i][j];
                    }
                }
                return M3;
            }
            
            matrixAdd(A, B, scale = 1) {
                const n = A.length;
                const C = [];
                for (let i = 0; i < n; i++) {
                    C[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        C[i][j] = A[i][j] + scale * B[i][j];
                    }
                }
                return C;
            }
            
            frobeniusNorm(M) {
                let sum = 0;
                for (let i = 0; i < M.length; i++) {
                    for (let j = 0; j < M[i].length; j++) {
                        sum += M[i][j] * M[i][j];
                    }
                }
                return Math.sqrt(sum);
            }
            
            powerIteration(M, maxIter = 50) {
                const n = M.length;
                let v = new Array(n);
                
                // Initialize with random vector
                for (let i = 0; i < n; i++) {
                    v[i] = Math.random() - 0.5;
                }
                
                // Normalize
                let norm = 0;
                for (let i = 0; i < n; i++) {
                    norm += v[i] * v[i];
                }
                norm = Math.sqrt(norm);
                if (norm > 0) {
                    for (let i = 0; i < n; i++) {
                        v[i] /= norm;
                    }
                }
                
                let eigenvalue = 0;
                
                for (let iter = 0; iter < maxIter; iter++) {
                    // Compute Mv
                    const Mv = new Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            Mv[i] += M[i][j] * v[j];
                        }
                    }
                    
                    // Compute Rayleigh quotient
                    let vMv = 0, vv = 0;
                    for (let i = 0; i < n; i++) {
                        vMv += v[i] * Mv[i];
                        vv += v[i] * v[i];
                    }
                    eigenvalue = vv > 0 ? vMv / vv : 0;
                    
                    // Update v
                    norm = 0;
                    for (let i = 0; i < n; i++) {
                        norm += Mv[i] * Mv[i];
                    }
                    norm = Math.sqrt(norm);
                    
                    if (norm > 0) {
                        for (let i = 0; i < n; i++) {
                            v[i] = Mv[i] / norm;
                        }
                    }
                }
                
                return { eigenvalue, eigenvector: v };
            }
            
            computePhi(M) {
                try {
                    const AM = this.matmul(this.A, M);
                    const AT = this.transpose(this.A);
                    const MAT = this.matmul(M, AT);
                    const MCube = this.hadamardCube(M);
                    
                    const phi = [];
                    for (let i = 0; i < this.n; i++) {
                        phi[i] = new Array(this.n);
                        for (let j = 0; j < this.n; j++) {
                            phi[i][j] = AM[i][j] + MAT[i][j] - this.lambda * MCube[i][j];
                        }
                    }
                    return phi;
                    
                } catch (error) {
                    showError(`Failed to compute Phi: ${error.message}`);
                    throw error;
                }
            }
            
            computeResonanceUpdate() {
                const n = this.n;
                const v = this.vMax;
                
                // Outer product vv^T
                const vvT = [];
                for (let i = 0; i < n; i++) {
                    vvT[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        vvT[i][j] = this.eta * v[i] * v[j];
                    }
                }
                
                // Projector P = I - vv^T
                const P = [];
                for (let i = 0; i < n; i++) {
                    P[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        P[i][j] = (i === j ? 1 : 0) - v[i] * v[j];
                    }
                }
                
                // PMP
                const PM = this.matmul(P, this.M);
                const PMP = this.matmul(PM, P);
                
                // δM_res = η*vv^T - γ*PMP
                const deltaM = [];
                for (let i = 0; i < n; i++) {
                    deltaM[i] = new Array(n);
                    for (let j = 0; j < n; j++) {
                        deltaM[i][j] = vvT[i][j] - this.gamma * PMP[i][j];
                    }
                }
                
                return deltaM;
            }
            
            evolve() {
                if (!this.isRunning) return;
                
                try {
                    // Store previous eigenvalue
                    this.lastLambdaMax = this.lambdaMax;
                    
                    // Compute eigendecomposition
                    const { eigenvalue, eigenvector } = this.powerIteration(this.M);
                    this.lambdaMax = eigenvalue;
                    this.vMax = eigenvector;
                    
                    // Estimate other eigenvalues for visualization
                    this.eigenvalues = [eigenvalue];
                    for (let i = 1; i < Math.min(this.n, 10); i++) {
                        const approx = eigenvalue * (1 - i * 0.15) * (0.8 + Math.random() * 0.4);
                        this.eigenvalues.push(approx);
                    }
                    
                    // Compute evolution terms
                    const phi = this.computePhi(this.M);
                    const deltaResonance = this.computeResonanceUpdate();
                    
                    // Update matrix
                    for (let i = 0; i < this.n; i++) {
                        for (let j = 0; j < this.n; j++) {
                            this.M[i][j] += this.dt * (
                                this.epsilon * phi[i][j] + deltaResonance[i][j]
                            );
                        }
                    }
                    
                    // Enforce symmetry
                    for (let i = 0; i < this.n; i++) {
                        for (let j = i + 1; j < this.n; j++) {
                            const avg = (this.M[i][j] + this.M[j][i]) / 2;
                            this.M[i][j] = this.M[j][i] = avg;
                        }
                    }
                    
                    // Update metrics
                    this.updateHistory();
                    this.time += this.dt;
                    this.timeSteps++;
                    
                    // Check stability
                    const frobNorm = this.frobeniusNorm(this.M);
                    if (frobNorm > 10) {
                        document.getElementById('stability').textContent = 'Unstable!';
                        document.getElementById('stability').style.color = '#d9534f';
                    } else {
                        document.getElementById('stability').textContent = 'Stable';
                        document.getElementById('stability').style.color = '#5cb85c';
                    }
                    
                } catch (error) {
                    showError(`Evolution step failed: ${error.message}`);
                    this.isRunning = false;
                }
            }
            
            updateHistory() {
                const frobNorm = this.frobeniusNorm(this.M);
                const dLambdaDt = (this.lambdaMax - this.lastLambdaMax) / this.dt;
                const inequalityRHS = this.eta * this.lambdaMax * this.lambdaMax - 
                                     this.lambda * frobNorm * frobNorm;
                
                this.history.time.push(this.time);
                this.history.lambdaMax.push(this.lambdaMax);
                this.history.frobeniusNorm.push(frobNorm);
                this.history.dLambdaDt.push(dLambdaDt);
                this.history.inequalityRHS.push(inequalityRHS);
                
                // Keep history bounded
                if (this.history.time.length > 500) {
                    Object.keys(this.history).forEach(key => {
                        this.history[key].shift();
                    });
                }
            }
            
            renderMatrix() {
                const ctx = this.matrixCtx;
                const canvas = this.matrixCanvas;
                const cellSize = canvas.width / this.n;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Find max value for normalization
                let maxVal = 0;
                for (let i = 0; i < this.n; i++) {
                    for (let j = 0; j < this.n; j++) {
                        maxVal = Math.max(maxVal, Math.abs(this.M[i][j]));
                    }
                }
                
                // Draw matrix cells
                for (let i = 0; i < this.n; i++) {
                    for (let j = 0; j < this.n; j++) {
                        const val = this.M[i][j];
                        const normalized = maxVal > 0 ? val / maxVal : 0;
                        
                        if (val > 0) {
                            const intensity = Math.floor(255 * Math.abs(normalized));
                            ctx.fillStyle = `rgb(255, ${255 - intensity}, 0)`;
                        } else {
                            const intensity = Math.floor(255 * Math.abs(normalized));
                            ctx.fillStyle = `rgb(0, ${255 - intensity}, 255)`;
                        }
                        
                        ctx.fillRect(
                            j * cellSize + 1, 
                            i * cellSize + 1, 
                            cellSize - 2, 
                            cellSize - 2
                        );
                    }
                }
            }
            
            renderSpectrum() {
                const ctx = this.spectrumCtx;
                const canvas = this.spectrumCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw axes
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, canvas.height - 50);
                ctx.lineTo(canvas.width - 20, canvas.height - 50);
                ctx.moveTo(50, 20);
                ctx.lineTo(50, canvas.height - 50);
                ctx.stroke();
                
                // Draw eigenvalues as bars
                if (this.eigenvalues.length > 0) {
                    const maxEig = Math.max(...this.eigenvalues.map(Math.abs), 0.1);
                    const barWidth = (canvas.width - 100) / this.eigenvalues.length;
                    
                    this.eigenvalues.forEach((eig, i) => {
                        const height = Math.abs(eig) / maxEig * (canvas.height - 100);
                        const x = 60 + i * barWidth;
                        const y = canvas.height - 50 - height;
                        
                        ctx.fillStyle = i === 0 ? '#4CAF50' : '#2196F3';
                        ctx.fillRect(x, y, barWidth * 0.8, height);
                    });
                    
                    // Label dominant eigenvalue
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Crimson Text';
                    ctx.fillText(`λ_max = ${this.lambdaMax.toFixed(3)}`, 60, 40);
                }
            }
            
            updateMetrics() {
                const latest = this.history.lambdaMax.length - 1;
                if (latest < 0) return;
                
                document.getElementById('lambda-max').textContent = 
                    this.lambdaMax.toFixed(3);
                document.getElementById('frobenius-norm').textContent = 
                    this.history.frobeniusNorm[latest].toFixed(3);
                document.getElementById('dlambda-dt').textContent = 
                    this.history.dLambdaDt[latest].toFixed(4);
                document.getElementById('inequality-rhs').textContent = 
                    this.history.inequalityRHS[latest].toFixed(4);
                document.getElementById('time-step').textContent = 
                    this.timeSteps;
            }
            
            testInequality() {
                const results = [];
                const numTests = Math.min(50, this.history.time.length - 1);
                let violations = 0;
                
                for (let i = this.history.time.length - numTests; i < this.history.time.length; i++) {
                    if (i < 1) continue;
                    
                    const dLambdaDt = this.history.dLambdaDt[i];
                    const rhs = this.history.inequalityRHS[i];
                    const holds = dLambdaDt >= rhs - 1e-6;
                    
                    if (!holds) violations++;
                    
                    results.push({
                        time: this.history.time[i].toFixed(2),
                        dLambdaDt: dLambdaDt.toFixed(4),
                        rhs: rhs.toFixed(4),
                        holds: holds
                    });
                }
                
                const output = document.getElementById('test-output');
                output.innerHTML = `
                    <p>Tested ${numTests} recent time steps</p>
                    <p>Violations: ${violations} (${(violations/numTests*100).toFixed(1)}%)</p>
                    <p>The thermodynamic inequality ${violations === 0 ? 'HOLDS' : 'is VIOLATED in some steps'}</p>
                    <details>
                        <summary>Show sample data</summary>
                        <pre>${JSON.stringify(results.slice(-5), null, 2)}</pre>
                    </details>
                `;
                
                document.getElementById('theorem-test-results').style.display = 'block';
                document.getElementById('theorem-test-results').className = 
                    violations === 0 ? 'alert alert-success' : 'alert alert-warning';
            }
            
            exportData() {
                const data = {
                    parameters: {
                        n: this.n,
                        epsilon: this.epsilon,
                        lambda: this.lambda,
                        eta: this.eta,
                        gamma: this.gamma,
                        alpha: this.alpha
                    },
                    history: this.history,
                    finalMatrix: this.M,
                    finalEigenvalues: this.eigenvalues
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], 
                    {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `abercrombie_data_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                debugLog('Data exported successfully');
            }
            
            reset() {
                debugLog(`Resetting system with dimension n=${this.n}`);
                this.M = this.initializeMatrix();
                this.A = this.initializeHereditaryKernel();
                this.time = 0;
                this.timeSteps = 0;
                this.lastLambdaMax = 0;
                this.lambdaMax = 0;
                this.history = {
                    time: [],
                    lambdaMax: [],
                    frobeniusNorm: [],
                    dLambdaDt: [],
                    inequalityRHS: []
                };
                clearError();
            }
        }
        
        // Initialize simulation
        let sim;
        try {
            sim = new AbercrombieMatrix(8);
        } catch (error) {
            showError(`Failed to initialize simulation: ${error.message}`);
        }
        
        // UI Event Handlers with error handling
        document.getElementById('dimension').addEventListener('input', (e) => {
            try {
                const n = parseInt(e.target.value);
                document.getElementById('dimension-display').textContent = `n = ${n}`;
                
                // Create new simulation with new dimension
                sim.isRunning = false;
                setTimeout(() => {
                    sim = new AbercrombieMatrix(n);
                    // Copy parameter values
                    sim.epsilon = parseFloat(document.getElementById('epsilon').value);
                    sim.lambda = parseFloat(document.getElementById('lambda').value);
                    sim.eta = parseFloat(document.getElementById('eta').value);
                    sim.gamma = parseFloat(document.getElementById('gamma').value);
                    sim.alpha = parseFloat(document.getElementById('alpha').value);
                    sim.isRunning = true;
                }, 100);
                
            } catch (error) {
                showError(`Failed to change dimension: ${error.message}`);
            }
        });
        
        document.getElementById('epsilon').addEventListener('input', (e) => {
            sim.epsilon = parseFloat(e.target.value);
            document.getElementById('epsilon-display').textContent = `ε = ${e.target.value}`;
        });
        
        document.getElementById('lambda').addEventListener('input', (e) => {
            sim.lambda = parseFloat(e.target.value);
            document.getElementById('lambda-display').textContent = `λ = ${e.target.value}`;
        });
        
        document.getElementById('eta').addEventListener('input', (e) => {
            sim.eta = parseFloat(e.target.value);
            document.getElementById('eta-display').textContent = `η = ${e.target.value}`;
        });
        
        document.getElementById('gamma').addEventListener('input', (e) => {
            sim.gamma = parseFloat(e.target.value);
            document.getElementById('gamma-display').textContent = `γ = ${e.target.value}`;
        });
        
        document.getElementById('alpha').addEventListener('input', (e) => {
            sim.alpha = parseFloat(e.target.value);
            document.getElementById('alpha-display').textContent = `α = ${e.target.value}`;
            sim.A = sim.initializeHereditaryKernel();
        });
        
        document.getElementById('play-pause').addEventListener('click', (e) => {
            sim.isRunning = !sim.isRunning;
            e.target.textContent = sim.isRunning ? 'Pause' : 'Play';
            debugLog(sim.isRunning ? 'Simulation resumed' : 'Simulation paused');
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            try {
                sim.reset();
                clearError();
            } catch (error) {
                showError(`Reset failed: ${error.message}`);
            }
        });
        
        document.getElementById('export-data').addEventListener('click', () => {
            try {
                sim.exportData();
            } catch (error) {
                showError(`Export failed: ${error.message}`);
            }
        });
        
        document.getElementById('test-theorem').addEventListener('click', () => {
            try {
                sim.testInequality();
            } catch (error) {
                showError(`Test failed: ${error.message}`);
            }
        });
        
        // Animation loop with error handling
        let lastTime = 0;
        let frameCount = 0;
        
        function animate(currentTime) {
            try {
                const deltaTime = currentTime - lastTime;
                
                // Evolve every 50ms
                if (deltaTime > 50) {
                    sim.evolve();
                    sim.renderMatrix();
                    sim.renderSpectrum();
                    sim.updateMetrics();
                    lastTime = currentTime;
                    
                    // Debug every 100 frames
                    frameCount++;
                    if (frameCount % 100 === 0) {
                        debugLog(`Running: t=${sim.time.toFixed(2)}, λ_max=${sim.lambdaMax.toFixed(3)}`);
                    }
                }
                
                requestAnimationFrame(animate);
                
            } catch (error) {
                showError(`Animation error: ${error.message}`);
                sim.isRunning = false;
            }
        }
        
        // Start animation
        requestAnimationFrame(animate);
        
        debugLog('Animation started');
    </script>
</body>
</html>
